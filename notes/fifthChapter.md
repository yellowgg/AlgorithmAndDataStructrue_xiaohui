# 面试中的算法
# 如何判断链表有环
### 小灰的解法
1. 首先从头节点开始，依次遍历单链表中的每一个节点，每遍历一个新节点，就从头检查新节点之前的所有节点，用新节点
和此节点之前的所有节点依次比较。如果发现新节点和之前的某个节点相同，则说明该节点被遍历过两次，
链表有环;如果之前的所有节点中不存在与新节点相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。  
假设链表的节点数为n，则时间复杂度为***O(n²)***，空间复杂度为***O(1)***  
2. 首先创建一个以节点ID为Key的HashSet集合，用来存储曾经遍历过的节点。然后同样从头开始遍历链表节点，
每遍历一个新节点，都用新节点和HashSet集合中存储的节点比较，如果发现HashSet中存在相同的节点，则说明链表有环;
如果不存在相同的节点ID，就把这个新节点ID存入HashSet中，之后进入下一个节点，继续重复刚才的操作。  
假设链表的节点数为n，则时间复杂度是***O(n)***，由于使用了额外的存储空间，所以空间复杂度也是***O(n)***
### 解体思路  
首先创建两个指针p1和p2，让它们同时指向这个链表的头节点。然后开始一个大循环。  
在循环体中，让指针p1每次向后移1个节点，让指针p2每次向后移动2个节点，  
然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，否则继续下一次循环。  
#### 思路原理
采用的是数学上的追及问题，在环形跑道上的两个运动员，一快一慢，肯定快的会追上慢的并超过。  
因为跑道是环形的。
### 时空复杂度
假设链表的节点数为n，则时间复杂度为***O(n)***，  
除了两个指针外，并没有使用额外的存储空间，所以空间复杂度为***O(1)***。