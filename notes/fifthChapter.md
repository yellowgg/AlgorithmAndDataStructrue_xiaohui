# 面试中的算法
# 如何判断链表有环
### 题目
有一个单向链表，链表中可能出现“环”，如何判断呢？
### 小灰的解法
1. 首先从头节点开始，依次遍历单链表中的每一个节点，每遍历一个新节点，就从头检查新节点之前的所有节点，用新节点
和此节点之前的所有节点依次比较。如果发现新节点和之前的某个节点相同，则说明该节点被遍历过两次，
链表有环;如果之前的所有节点中不存在与新节点相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。  
假设链表的节点数为n，则时间复杂度为***O(n²)***，空间复杂度为***O(1)***  
2. 首先创建一个以节点ID为Key的HashSet集合，用来存储曾经遍历过的节点。然后同样从头开始遍历链表节点，
每遍历一个新节点，都用新节点和HashSet集合中存储的节点比较，如果发现HashSet中存在相同的节点，则说明链表有环;
如果不存在相同的节点ID，就把这个新节点ID存入HashSet中，之后进入下一个节点，继续重复刚才的操作。  
假设链表的节点数为n，则时间复杂度是***O(n)***，由于使用了额外的存储空间，所以空间复杂度也是***O(n)***
### 大黄的解题思路  
首先创建两个指针p1和p2，让它们同时指向这个链表的头节点。然后开始一个大循环。  
在循环体中，让指针p1每次向后移1个节点，让指针p2每次向后移动2个节点，  
然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，否则继续下一次循环。  
#### 思路原理
采用的是数学上的追及问题，在环形跑道上的两个运动员，一快一慢，肯定快的会追上慢的并超过。  
因为跑道是环形的。
### 时空复杂度
假设链表的节点数为n，则时间复杂度为***O(n)***，  
除了两个指针外，并没有使用额外的存储空间，所以空间复杂度为***O(1)***。
### 问题扩展
- 如果链表有环，如何求出环的长度？  

当两个指针首次相遇时，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进  
的循环次数，直到两个指针第2次相遇，此时，统计出来的前进次数就是环长。  
因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针相遇时，p2比p1多走一圈  
因此有  
***环长 = 每一次速度差 X 前进次数 = 前进次数***

- 如果链表有环，如何求出入环节点？

将有环链表抽象示意成下图  
![Vm85FO.png](https://s2.ax1x.com/2019/05/28/Vm85FO.png)  
假设，从链表头节点到入环点的距离是D，从入环点到两个指针首次相遇点的距离是S1，从首次相遇点回到入环点的距离是S2。  
那么有，  
指针p1一次走1步，所走的距离是D+S1。  
指针p2一次走2步，多走了1整圈，所走的距离是D+S1+S2+S1 = D+2S1+S2。  
由于p2的速度是p1的2倍，所以所走距离也是p1的2倍，则有  
　　　　　　　　　　2(D+S1)=D+2S1+S2  
整理得出  
　　　　　　　　　　D=S2  
也就是说，从链表头节点到入环点的距离，等于首次相遇点回到入环点的距离  
这样一来，只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，  
两个指针都是每次向前走1步，那么，它们最终相遇的节点就是入环节点。

# 最小栈的实现
### 题目
实现一个栈，该栈带有出栈(pop)、入栈(push)、取最小元素(getMin)3个方法。  
要保证这3个方法的时间复杂度都是O(1)

### 小灰的解法
1. 创建一个变量min，用于存储栈中的最小元素，当第一个元素进栈时，min保存该元素做最小值  
2. 之后每一个元素进栈都跟min做比较，如果小于min就更新min，否则不做改变
3. 当调用getMin方法时，直接返回min的值

小灰解法的缺陷是只考虑了进栈场景，没有考虑出栈场景，当调用getMin之后，min的值就不知道是多少了。  

### 大黄的解题思路
1. 设原有的栈叫栈A，此时创建一个额外的“备胎”栈叫栈B。
2. 当第一个元素进栈A时，让它也进栈B，这样栈B存储的就是最小值
3. 当新元素进栈A时，就让它跟栈B的栈顶元素(此元素是栈A的最小值)比较，如果小于栈顶元素就跟着进栈B  
4. 当元素出栈A时，如果出栈元素是栈B的栈顶元素，那么两个栈都出，这样栈B的新栈顶元素就是最小值  
5. 当调用getMin时，返回栈B的栈顶元素的值， 无需任何一个栈出栈。

### 时空复杂度
显然这个解法中进栈、出栈、取最小值的时间复杂度都是***O(1)***，  
最坏情况下空间复杂度是***O(n)***（假如栈A是4321，那么栈B也是4321，所以最坏是O(n)）

# 求最大公约数
### 题目
写一段代码，求出两个整数的最大公约数，要尽量优化算法的性能

### 小灰的解法
使用暴力枚举的方法，从较小整数的一半开始，试图找到一个合适的整数i，  
看这个整数能否被a和b同时整除。

小灰解法的缺陷是性能严重不足，如果传入的整数是10000和10001，那么就需要循环10000/2-1=4999次  

### 大黄的解题思路
- 辗转相除法：***两个正整数a和b(a>b)，它们的最大公约数等于a除以b的余数c和b之间的最大公约数***  
例如10和25，25除以10商2余5，那么10和25的最大公约数，等同于10和5的最大公约数。  
首先，计算出a除以b的余数c，把问题瓷砖化成求b和c的最大公约数;然后计算出b除以c的余数d，把问题转化成求c和d的最大公约数。  
以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小到1为止。
- 更相减损术：***两个正整数a和b(a>b)，它们的最大公约数等于a-b的差值c和较小数b的最大公约数***  
例如10和25，25减10的差是15，那么10和25的最大公约数，等同于10和15的最大公约数。  
首先，计算出a和b的差值c(假设a>b)，把问题转发成求b和c的最大公约数;然后计算出c和b的差值d(假设c>b)，把问题转化成求b和d的最大公约数。  
以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以相等为止，最大公约数就是最终相等的这两个数的值。

- 辗转相除法和更相减损术结合
众所周知，移位运算的性能非常好。  
```
当a和b均为偶数时，gcd(a,b) = 2 x gcd(a/2,b/2) = 2 x gcd(a>>1,b>>1)
当a为偶数，b为奇数时，gcd(a,b) = gcd(a/2,b) = gcd(a>>1,b)
当a为奇数，b为偶数时，gcd(a,b) = gcd(a,b/2) = gcd(a,b>>1)
当a和b均为奇数时，先利用更相减损术运算一次，gcd(a,b) = gcd(b,a-b)，此时a-b必然是偶数，然后又可以继续进行移位运算
```
例如计算10和25的最大公约数的步骤如下
1. 整数10通过移位，可以转换成求5和25的最大公约数
2. 利用更相减损术，计算25-5=20，转换成求5和20的最大公约数
3. 整数20通过移位，可以转换成求5和10的最大公约数  
4. 整数10通过移位，可以转换成求5和5的最大公约数
5. 利用更相减损术，因为两数相等，所以最大公约数是5

这种方式在两数都比较小时，可能看不出计算次数的优势，当两数越大时，计算次数的减少就会越明显

### 时空复杂度
1. ***暴力枚举法***：时间复杂度是***O(min(a,b))***
2. ***辗转相除法***：时间复杂度不太好计算，可以近似为***O(log(max(a,b)))***，但是取模运算比较差
3. ***更相减损术***：避免了取模运算，但是算法性能不稳定，最坏时间复杂度是***O(max(a,b))***
4. ***更相减损术与辗转相除法结合***：不但避免了取模运算，而且算法性能稳定，时间复杂度为***O(log(max(a,b)))***

# 判断一个数是否为2的整数次幂
### 题目
实现一个方法，来判断一个正整数是否是2的整数次幂。要求性能尽可能高  

### 小灰的解法
利用一个整形变量，让它从1开始不断乘以2，将每一次乘以2的结果加以判断。  
具体做法：  
创建一个中间变量temp，初始值是1。然后进入一个循环，每次循环都让temp和目标整数比较，
如果相等，则说明目标整数是2的整数次幂;如果不相等，则让temp增大1倍，继续循环比较。
当temp的值大于目标整数时，说明目标整数不是2的整数次幂。  
此种方法是原始的方法，时间复杂度为***O(logn)***

### 大黄的解题思路
将2的整数次幂转换成二进制

| 十进制 | 二进制 | 是否为2的整数次幂 |
| ----| --- | ---- |
| 8   | 1000B  | 是 |
| 16  | 10000B  | 是 |
| 32  | 100000B  | 是 |
| 64  | 1000000B  | 是 |
| 100 | 1100100B  | 否 |

根据上表可得出如果一个整数是2的整数次幂，那么它的二进制就是最高位是1,其它位都是0  

将2的整数次幂各自减1,再转换成二进制

| 十进制 | 二进制 | 原数值-1 | 是否为2的整数次幂 |
| ----| --- | -------- | ---- |
| 8   | 1000B  | 111B | 是 |
| 16  | 10000B  | 1111B | 是 |
| 32  | 100000B  | 11111B | 是 |
| 64  | 1000000B  | 111111B | 是 |
| 100 | 1100100B  | 1100011B |否 |

根据上表可得出2的整数次幂一旦减1，它的二进制就全都是1  

用原数值(2的整数次幂)和它减1的结果进行按位与运算，也就是n&(n-1)

| 十进制 | 二进制 | 原数值-1 | n&n-1 | 是否为2的整数次幂 |
| ----| --- | -------- | ------- | ---- |
| 8   | 1000B  | 111B | 0 | 是 |
| 16  | 10000B  | 1111B | 0 | 是 |
| 32  | 100000B  | 11111B | 0 | 是 |
| 64  | 1000000B  | 111111B | 0 | 是 |
| 100 | 1100100B  | 1100011B | 1100000B |否 |

0和1按位与运算的结果是0，所以凡是2的整数次幂和它本身减1的结果进行与运算，  
结果必定都是0，反之，如果一个整数不是2的整数次幂，结果一定不是0

### 时空复杂度
因为就只是判断n&n-1是否等于0，所以可得知时间复杂度为***O(1)***

# 无序数组排序后的最大相邻差
### 题目
有一个无序整形数组，如何求出该数组排序后的任意两个相邻元素的最大差值？  
要求时间和控件复杂度尽可能低。示意图如下  
![VQv3Ax.png](https://s2.ax1x.com/2019/05/31/VQv3Ax.png)

### 小灰的解法
使用任意一种时间复杂度为O(nlogn)的排序算法(如快速算法)给原数组排序，
然后遍历排序好的数组，并对每两个相邻元素求差，最终得到最大差值。  
该解法的时间复杂度是O(nlogn)，在不改变原数组的情况下，空间复杂度是O(n)。　　

小灰解法的缺陷是这道题的目的显然不是为了排序，而是从别的方面下手。

### 大黄的解题思路
- 解法一
    1. 利用计数排序的思想，先求出原数组的最大值max和最小值min的区间长度k(k=max-min+1)，
    以及偏移量d=min;
    2. 创建一个长度为k的新数组Array。
    3. 遍历原数组，每遍历一个元素，就把新数组Array对应下标的值+1。  
    例如原数组元素的值为n，则将Array[n-min]的值加1，遍历结束后，Array的一部分元素变成了1或者更高的数值，一部分元素值仍然是0。
    4. 遍历新数组Array，统计出Array中最大连续出现0值的次数+1，则为相邻元素最大差值。
    
此解法的缺陷跟计数排序的缺陷一样，当最大最小值相差过大，就要创建过长的无用数组，所以继续依靠桶排序的思想优化

- 解法二
    1. 利用桶排序的思想，根据原数组的长度n，创建出n个桶，每一个桶代表一个区间范围。  
    其中第1个桶从原数组的最小值min开始，区间跨度是(max-min)/(n-1)
    2. 遍历原数组，把原数组每一个元素插入到对应的桶中，记录每一个桶的最大和最小值
    3. 遍历素有的桶，统计出每一个桶的最大值，和这个桶的右侧非空桶的最小值的差，  
    数值最大的差就是我们所求的最大相邻差
    
### 时空复杂度
大黄的解法二不需要像标准桶排序那样给每一个桶内部进行排序，只需要记录桶内的最大最小值，所以时间复杂度稳定在***O(n)***

# 如何用栈实现队列
### 题目
用栈来模拟一个队列，要求实现队列的两个基本操作：出队、入队。

### 小灰的解法
小灰选择死亡

### 大黄的解题思路
世界上没有什么队列是栈不能实现的，如果一个栈不行，那就两个栈
1. 入队  
直接把元素正常压入栈A
2. 出队  
先将元素从栈A弹出，然后再压入栈B(姑且称作元素迁移)，从栈B弹出就是队列的出队

### 时空复杂度
入队操作的时间复杂度是***O(1)***  
出队操作  
如果涉及栈A和栈B的元素迁移，那么一次出队的时间复杂度是***O(n)***  
如果不涉及迁移或者不用迁移，时间复杂度是***O(1)***  
以上涉及一个新的概念：***均摊时间复杂度***  
需要元素迁移的出队操作只有少数情况，并且不可能连续出现，其后的大多数出队操作都不需要元素迁移 
所以把时间均摊到每一次出队操作上面，其时间复杂度是***O(1)***，这个概念不常用，稍作了解即可。

# 寻找全排列的下一个数
### 题目
给出一个正整数，找出这个正整数所有数字全排列的下一个数。  
通俗点说就是在一个整数所包含数字的全部组合中，找到一个大于且仅大于原数的新整数。例如  
如果输入12345，则返回12354。
如果输入12354，则返回12435。
如果输入12435，则返回12453。

### 小灰的解法
小灰再次选择死亡

### 大黄的解题思路
固定的几个数，在***逆序排列***的情况下最大，在***顺序排列***的情况下最小，这是全排列中的两种极端情况。  
我们需要尽量保持高位不变，低位在最小的范围内变换顺序。至于变换顺序的范围大小，则取决于当前整数的逆序区域。  
所以可以总结出获得全排列下一个数的3个步骤
1. 从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的边界。  
2. 让逆序区域的前一位和逆序区域中大于它的最小的数字交换位置。  
3. 把原来的逆序区域转为顺序状态。

其实这就是传说的***字典序算法***。

### 时空复杂度
该算法3个步骤每一步的时间复杂度都是O(n)，所以整体的时间复杂度也是***O(n)***

# 删除k个数字后的最小值
### 题目
给出一个整数，从该整数中去掉k个数字，要求剩下的数字形成的新整数尽可能小。

### 小灰的解法
它觉得优先删除最大的数字，这点从第一感觉上来说是没错，但其实就是错的。  
所以小灰又双叒叕选择了死亡

### 大黄的解题思路
- 优先删除高位的数字  
把原整数的所有数字从左到右进行比较，如果发现某一位数字大于它后面的数字，那么在删除该数字后，必然会使该数位的值降低  

像这种不断的求得***局部最优解***，最终得到***全局最优解***的思想，就叫做***贪心算法***  

其实我以前做这道题的时候也是像小灰那样先排序，然后再删掉高位的大数字，然而总是错，后来才知道是贪心算法的题  

### 时空复杂度
根据代码可分析出只对所有数字遍历了一次，遍历的时间复杂度是O(n)，  
把栈转化为字符串的时间复杂度也是O(n)，所以最终的时间复杂度是***O(n)***  
同时，程序中利用栈来回溯遍历过的数字及删除数字，所以程序的空间复杂度是***O(n)***  

# 大数加法
### 题目
给出两个很大的整数，要求实现程序求出两个整数之和  

### 小灰的解法
小灰已经凉了

### 大黄的解体思路
**大数加法就是采用数组模拟竖式运算**  
1. 创建两个整形数组，长度是较大整数的位数+1，把每一个整数都储存到数组中，整数的个位位于数组下标为0的位置，最高位位于数组的尾部。  
2. 创建结果数组，结果数组的长度同样是较大整数的位数+1，+1的目地很明显是给最高位进位预留的。  
3. 遍历两个数组，从左到右按照对应下标把元素两两相加，就跟竖式相加一样。
4. 把结果数组的全部元素再次逆序，去掉首位的0，就是最终结果。

需要说明的是，为两个大整数创建临时数组，是一种直观的解决方案。若想节省内存空间，也可以不创建。  

### 时空复杂度
如果给出的大整数的最长位数是n，那么创建数组、按位计算、结果逆序的时间复杂度各自都是O(n)。  
整体的时间复杂度也是***O(n)***

其实也可以有优化，比如每个大整数是50位，那么就要创建长度51的数组，但其实不用，我们不用拆分这么细，只需要拆分到可以被直接计算的程度就够了。  
思路是比如int类型的范围是-2147483648 ~ 2147 483 647，最多可以有10位整数，为了防止溢出，可以把大整数的每9位作为数组的一个元素，进行加法运算。
