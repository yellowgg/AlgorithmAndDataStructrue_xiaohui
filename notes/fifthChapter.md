# 面试中的算法
# 如何判断链表有环
### 题目
有一个单向链表，链表中可能出现“环”，如何判断呢？
### 小灰的解法
1. 首先从头节点开始，依次遍历单链表中的每一个节点，每遍历一个新节点，就从头检查新节点之前的所有节点，用新节点
和此节点之前的所有节点依次比较。如果发现新节点和之前的某个节点相同，则说明该节点被遍历过两次，
链表有环;如果之前的所有节点中不存在与新节点相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。  
假设链表的节点数为n，则时间复杂度为***O(n²)***，空间复杂度为***O(1)***  
2. 首先创建一个以节点ID为Key的HashSet集合，用来存储曾经遍历过的节点。然后同样从头开始遍历链表节点，
每遍历一个新节点，都用新节点和HashSet集合中存储的节点比较，如果发现HashSet中存在相同的节点，则说明链表有环;
如果不存在相同的节点ID，就把这个新节点ID存入HashSet中，之后进入下一个节点，继续重复刚才的操作。  
假设链表的节点数为n，则时间复杂度是***O(n)***，由于使用了额外的存储空间，所以空间复杂度也是***O(n)***
### 大黄的解体思路  
首先创建两个指针p1和p2，让它们同时指向这个链表的头节点。然后开始一个大循环。  
在循环体中，让指针p1每次向后移1个节点，让指针p2每次向后移动2个节点，  
然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，否则继续下一次循环。  
#### 思路原理
采用的是数学上的追及问题，在环形跑道上的两个运动员，一快一慢，肯定快的会追上慢的并超过。  
因为跑道是环形的。
### 时空复杂度
假设链表的节点数为n，则时间复杂度为***O(n)***，  
除了两个指针外，并没有使用额外的存储空间，所以空间复杂度为***O(1)***。
### 问题扩展
- 如果链表有环，如何求出环的长度？  

当两个指针首次相遇时，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进  
的循环次数，直到两个指针第2次相遇，此时，统计出来的前进次数就是环长。  
因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针相遇时，p2比p1多走一圈  
因此有  
***环长 = 每一次速度差 X 前进次数 = 前进次数***

- 如果链表有环，如何求出入环节点？

将有环链表抽象示意成下图  
![Vm85FO.png](https://s2.ax1x.com/2019/05/28/Vm85FO.png)  
假设，从链表头节点到入环点的距离是D，从入环点到两个指针首次相遇点的距离是S1，从首次相遇点回到入环点的距离是S2。  
那么有，  
指针p1一次走1步，所走的距离是D+S1。  
指针p2一次走2步，多走了1整圈，所走的距离是D+S1+S2+S1 = D+2S1+S2。  
由于p2的速度是p1的2倍，所以所走距离也是p1的2倍，则有  
　　　　　　　　　　2(D+S1)=D+2S1+S2  
整理得出  
　　　　　　　　　　D=S2  
也就是说，从链表头节点到入环点的距离，等于首次相遇点回到入环点的距离  
这样一来，只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，  
两个指针都是每次向前走1步，那么，它们最终相遇的节点就是入环节点。

# 最小栈的实现
### 题目
实现一个栈，该栈带有出栈(pop)、入栈(push)、取最小元素(getMin)3个方法。  
要保证这3个方法的时间复杂度都是O(1)

### 小灰的解法
1. 创建一个变量min，用于存储栈中的最小元素，当第一个元素进栈时，min保存该元素做最小值  
2. 之后每一个元素进栈都跟min做比较，如果小于min就更新min，否则不做改变
3. 当调用getMin方法时，直接返回min的值

小灰解法的缺陷是只考虑了进栈场景，没有考虑出栈场景，当调用getMin之后，min的值就不知道是多少了。  

### 大黄的解体思路
1. 设原有的栈叫栈A，此时创建一个额外的“备胎”栈叫栈B。
2. 当第一个元素进栈A时，让它也进栈B，这样栈B存储的就是最小值
3. 当新元素进栈A时，就让它跟栈B的栈顶元素(此元素是栈A的最小值)比较，如果小于栈顶元素就跟着进栈B  
4. 当元素出栈A时，如果出栈元素是栈B的栈顶元素，那么两个栈都出，这样栈B的新栈顶元素就是最小值  
5. 当调用getMin时，返回栈B的栈顶元素的值， 无需任何一个栈出栈。

### 时空复杂度
显然这个解法中进栈、出栈、取最小值的时间复杂度都是***O(1)***，  
最坏情况下空间复杂度是***O(n)***（假如栈A是4321，那么栈B也是4321，所以最坏是O(n)）
