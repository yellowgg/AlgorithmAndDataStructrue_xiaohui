# 排序
### 分类
1. 时间复杂度为O(n²)的排序算法  
    - 冒泡排序  
    - 选择排序  
    - 插入排序  
    - 希尔排序(希尔排序特殊，其性能略优于O(n²),但又比不上O(nlogn))  
  
2. 时间复杂度为O(nlogn)的排序算法  
    - 快速排序  
    - 归并排序  
    - 堆排序  

3. 时间复杂度为线性的排序算法  
    - 计数排序
    - 桶排序
    - 基数排序  

当然，以上列举的只是最主流的排序算法，在算法界还有很多有趣的算法。  
它们有些基于传统排序，有些则是脑洞大开，比如***鸡尾酒排序***，***猴子排序***以及大名鼎鼎的***睡眠排序***  
此外，排序算法还可以根据其稳定性，划分为***稳定排序***和***不稳定排序***
- 稳定排序　：值相同的元素在排序后仍然保持着排序前的顺序  
- 不稳定排序：值相同的元素在排序后打乱了排序前的顺序

# 冒泡排序
### 思想
把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置;  
当一个元素小于或等于右侧相邻元素时，位置不变。

***冒泡排序是一种稳定排序***

### 时间复杂度
由于冒泡排序算法的每一轮都要遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n²)

# 鸡尾酒排序
### 思想
跟冒泡差不多，只不过冒泡是每一轮的从左到右单向比较  
而鸡尾酒排序是从左到右然后从右到左以此反复，即双向比较  

- 优点：能够在特定条件下，减少排序的回合数
- 缺点：代码量比冒泡的增加了一部分（算不上什么缺点了吧）

总的而言，随机数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。

# 快速排序
### 思想
在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边  
比它小的元素移动到数列的另一边，从而把数列拆解成两个部分  
这种思路也称为***分治法***  
在***分治法***的思想下，原数列在每一轮都被拆分成两部分，每一部分在下一轮又分别被拆成两部分，直到不可再分为止  

### 时间复杂度
每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度是**O(n)**。  
这样的遍历一共需要多少轮呢？假如元素个数是n，那么平均情况下需要logn轮。  
因此快排算法总体的平均时间复杂度是***O(nlogn)***，当然也有极端的坏情况，时间复杂度为***O(n²)***

### 基准元素的选择
如果基准元素选取的元素是整个数列的最大值或最小值， 会影响到快排的效率。  
这样会无法发挥分治法的优势，遇到这种极端情况，时间复杂度就退化到***O(n²)***。  
所以可以随机选择一个元素作为基准元素，然后再跟第一个元素交换位置  

### 元素的交换
1. 双边循环法  
2. 单边循环法

***双边循环法***  
选定基准元素pivot，并且设置两个指针left和right，分别指向数列的最左和最右两个元素。  
先从***right***指针开始移动，比较指向元素和基准元素的值，  
如果***大于或等于***pivot，则指针继续向***左***移动;  
如果***小于***pivot，则***right***指针停止移动，切换到***left***指针。  
然后***left***指针开始一动，比较指向元素和基准元素的值，  
如果***小于或等于***pivot，则指针继续向***右***移动;  
如果***大于***pivot，则***left***指针停止移动，然后让***left***和***right***所指向的元素交换  
最后当***left***和***right***重合时，就将指向元素和基准元素交换，结束。  

***单边循环法***  
选定基准元素pivot，设置一个mark指针指向数列起始位置，这个mark指针代表***小于基准元素的区域边界***  
从基准元素的下一个位置开始遍历  
如果遍历到的元素大于基准元素，往后遍历  
如果遍历到的元素小于基准元素，则需要做两件事  
第一，把mark指针右移1位，因为代表这小于基准元素的区域变大了  
第二，让最新遍历到的元素和mark指针所在位置的元素交换位置，因为这个新元素就是属于小于基准元素的区域  
最后把基准元素交换到mark指针所在位置， 结束，此时基准元素两边就是一小一大的区域。

# 堆排序
### 步骤
1. 把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆;需要从大到小排序，则构建成最小堆  
2. 循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶

### 时空复杂度
- 空间复杂度：没有开辟额外的集合空间，所以为***O(1)***
- 时间复杂度：先把无序数组构建成二叉堆，这一步为***O(n)***，然后需要进行n-1次循环，每次循环调用一次downAdjust方法，所以计算规模是
(n-1)xlogn，所以为***O(nlogn)***

## 堆排序和快速排序比较  
1. 相同点
    - 平均时间复杂度都是***O(nlogn)***  
    - 都是***不稳定排序***
2. 不同点
    - 快排的最坏时间复杂度是***O(n²)***
    - 堆排序的最坏时间复杂度是***O(nlogn)***

此外，快速排序递归和非递归方法的平均**空间复杂度**都是***O(nlogn)***  
而堆排序的空间复杂度是***O(1)***


# 计数排序
有一些特殊的排序并不基于元素比较，如***计数排序***，***桶排序***，***基数排序***  
### 朴素版计数排序
***思想***:遍历无序数组，每一个整数按照其值对号入座，同时数组下标的元素加1  
然后遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。  

***缺陷***
1. 因为是以数组的最大值来决定统计数组的长度，所以并不严谨，如下  
数列为95,94,91,98,99,90,99,93,91,92  
这个数列的最大值是99，但最小的整数却是90，如果创建长度为100的数组，前面就浪费了  
2. 朴素版计数排序只是简单的按照统计数组的下标输出元素值，并没有真正给原始数列进行排序


### 优化版计数排序  
针对上面的缺陷，可以优化一下。  
只要不再以***输入数列的最大值+1***作为统计数组的长度，  
而是以***数列最大值-最小值+1***作为统计数组的长度即可  
同时，数列的最小值作为一个偏移量，用于计算整数在统计数组中的下标
***缺陷***
1. 如果只是单纯的排序，上面的优化点已经足够了，但是在现实中，  
例如给学生的考试分数进行排序，遇到相同的分数就会分不清谁是谁  

***优化***  
从统计数组的第二个元素开始，每一个元素都加上前面所有元素之和  
这样相加的目的是为了让统计数组存储的元素值，等于相应整数的最终排序位置的序号  
意思就是排第几名，具体参考书本p142。  
这样，排序之后相同元素的位置不变，所以优化后的计数排序属于***稳定排序***  

### 时空复杂度
设原始数列的规模是n，最大和最小整数的差值是m
- 时间复杂度为***O(n+m)***
- 空间复杂度为***O(m)***

具体参考代码里的说明

### 局限性
1. ***当数列最大和最小值差距过大时，并不适合用计数排序***  
例如给出20个随机整数，范围在0到1亿之间，这时如果使用技术排序，需要创建极长数组  
不但严重浪费空间，而且时间复杂度也会随之升高。
2. ***当数列元素不是整数时，也不适合用计数排序***  
如果数列中的元素都是小数时，如25.12，或者0.0000001这样的数字，则无法创建对应的数组  
这样显然无法进行计数排序


对于这些局限性，另一种线性时间排序算法做出了弥补，她就是***桶排序***

# 桶排序
桶排序是一种线性时间的排序算法，类似于计数排序所创键的统计数组，  
桶排序需要创建若干个桶来协助排序  

### 步骤
1. 创建桶，并确定每一个桶的范围  
具体创建多少桶，如何确定桶的区间范围，有很多种不同的方式。  
文中选用的是创建的桶数量等于原始数列的元素数量，除最后一个桶质包含数列最大值，  
前面各个桶的区间按照比例来确定  
***区间跨度 = (最大值 - 最小值) / (桶的数量 - 1)***

2. 遍历原始数列，把元素对号入座放入各个桶中  

3. 对每个桶内部的元素分别进行排序

4. 遍历所有的桶，输出所有元素

### 时空复杂度
假设原始数列有n个元素，分成n个桶。  
1. 求数列最大、最小值，运算量为n  
2. 创建空桶，运算量为n  
3. 把原始数列的元素分配到各个桶中，运算量为n  
4. 在每个桶内部做排序，在元素分布相对均匀的情况下，所有桶的运算量之和为n  
5. 输出排序数列，运算量为n
因此桶排序的总体时间复杂度为***O(n)***  
至于空间复杂度就很容易得到了，同样是***O(n)***  

### 注意
桶排序的性能并非绝对稳定，如果元素的分布既不均衡，  
在极端情况下， 第一个桶中有n-1个元素，最后一个桶中有1个元素，  
此时的时间复杂度将退化为***O(nlogn)***  
而且还白白创建了许多空桶  
由此可见，没有绝对好的算法，也没有绝对不好的算法，关键要看具体的场景  


