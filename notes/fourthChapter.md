# 排序
### 分类
1. 时间复杂度为O(n²)的排序算法  
    - 冒泡排序  
    - 选择排序  
    - 插入排序  
    - 希尔排序(希尔排序特殊，其性能略优于O(n²),但又比不上O(nlogn))  
  
2. 时间复杂度为O(nlogn)的排序算法  
    - 快速排序  
    - 归并排序  
    - 堆排序  

3. 时间复杂度为线性的排序算法  
    - 计数排序
    - 桶排序
    - 基数排序  

当然，以上列举的只是最主流的排序算法，在算法界还有很多有趣的算法。  
它们有些基于传统排序，有些则是脑洞大开，比如***鸡尾酒排序***，***猴子排序***以及大名鼎鼎的***睡眠排序***  
此外，排序算法还可以根据其稳定性，划分为***稳定排序***和***不稳定排序***
- 稳定排序　：值相同的元素在排序后仍然保持着排序前的顺序  
- 不稳定排序：值相同的元素在排序后打乱了排序前的顺序

# 冒泡排序
### 思想
把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置;  
当一个元素小于或等于右侧相邻元素时，位置不变。

***冒泡排序是一种稳定排序***

### 时间复杂度
由于冒泡排序算法的每一轮都要遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n²)

# 鸡尾酒排序
### 思想
跟冒泡差不多，只不过冒泡是每一轮的从左到右单向比较  
而鸡尾酒排序是从左到右然后从右到左以此反复，即双向比较  

- 优点：能够在特定条件下，减少排序的回合数
- 缺点：代码量比冒泡的增加了一部分（算不上什么缺点了吧）

总的而言，随机数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。

# 快速排序
### 思想
在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边  
比它小的元素移动到数列的另一边，从而把数列拆解成两个部分  
这种思路也称为***分治法***  
在***分治法***的思想下，原数列在每一轮都被拆分成两部分，每一部分在下一轮又分别被拆成两部分，直到不可再分为止  

### 时间复杂度
每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度是**O(n)**。  
这样的遍历一共需要多少轮呢？假如元素个数是n，那么平均情况下需要logn轮。  
因此快排算法总体的平均时间复杂度是***O(nlogn)***，当然也有极端的坏情况，时间复杂度为***O(n²)***

### 基准元素的选择
如果基准元素选取的元素是整个数列的最大值或最小值， 会影响到快排的效率。  
这样会无法发挥分治法的优势，遇到这种极端情况，时间复杂度就退化到***O(n²)***。  
所以可以随机选择一个元素作为基准元素，然后再跟第一个元素交换位置  

### 元素的交换
1. 双边循环法  
2. 单边循环法

***双边循环法***  
选定基准元素pivot，并且设置两个指针left和right，分别指向数列的最左和最右两个元素。  
先从***right***指针开始移动，比较指向元素和基准元素的值，  
如果***大于或等于***pivot，则指针继续向***左***移动;  
如果***小于***pivot，则***right***指针停止移动，切换到***left***指针。  
然后***left***指针开始一动，比较指向元素和基准元素的值，  
如果***小于或等于***pivot，则指针继续向***右***移动;  
如果***大于***pivot，则***left***指针停止移动，然后让***left***和***right***所指向的元素交换  
最后当***left***和***right***重合时，就将指向元素和基准元素交换，结束。
