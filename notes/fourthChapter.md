# 排序
### 分类
1. 时间复杂度为O(n²)的排序算法  
    - 冒泡排序  
    - 选择排序  
    - 插入排序  
    - 希尔排序(希尔排序特殊，其性能略优于O(n²),但又比不上O(nlogn))  
  
2. 时间复杂度为O(nlogn)的排序算法  
    - 快速排序  
    - 归并排序  
    - 堆排序  

3. 时间复杂度为线性的排序算法  
    - 计数排序
    - 桶排序
    - 基数排序  

当然，以上列举的只是最主流的排序算法，在算法界还有很多有趣的算法。  
它们有些基于传统排序，有些则是脑洞大开，比如***鸡尾酒排序***，***猴子排序***以及大名鼎鼎的***睡眠排序***  
此外，排序算法还可以根据其稳定性，划分为***稳定排序***和***不稳定排序***
- 稳定排序　：值相同的元素在排序后仍然保持着排序前的顺序  
- 不稳定排序：值相同的元素在排序后打乱了排序前的顺序

# 冒泡排序
### 思想
把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置;  
当一个元素小于或等于右侧相邻元素时，位置不变。

***冒泡排序是一种稳定排序***

### 时间复杂度
由于冒泡排序算法的每一轮都要遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n²)

# 鸡尾酒排序
### 思想
跟冒泡差不多，只不过冒泡是每一轮的从左到右单向比较  
而鸡尾酒排序是从左到右然后从右到左以此反复，即双向比较  

- 优点：能够在特定条件下，减少排序的回合数
- 缺点：代码量比冒泡的增加了一部分（算不上什么缺点了吧）

总的而言，随机数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。

# 快速排序
### 思想
在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边  
比它小的元素移动到数列的另一边，从而把数列拆解成两个部分  
这种思路也称为***分治法***  
在***分治法***的思想下，原数列在每一轮都被拆分成两部分，每一部分在下一轮又分别被拆成两部分，直到不可再分为止  

### 时间复杂度
每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度是**O(n)**。  
这样的遍历一共需要多少轮呢？假如元素个数是n，那么平均情况下需要logn轮。  
因此快排算法总体的平均时间复杂度是***O(nlogn)***，当然也有极端的坏情况，时间复杂度为***O(n²)***

### 基准元素的选择
如果基准元素选取的元素是整个数列的最大值或最小值， 会影响到快排的效率。  
这样会无法发挥分治法的优势，遇到这种极端情况，时间复杂度就退化到***O(n²)***。  
所以可以随机选择一个元素作为基准元素，然后再跟第一个元素交换位置  

### 元素的交换
1. 双边循环法  
2. 单边循环法

***双边循环法***  
选定基准元素pivot，并且设置两个指针left和right，分别指向数列的最左和最右两个元素。  
先从***right***指针开始移动，比较指向元素和基准元素的值，  
如果***大于或等于***pivot，则指针继续向***左***移动;  
如果***小于***pivot，则***right***指针停止移动，切换到***left***指针。  
然后***left***指针开始一动，比较指向元素和基准元素的值，  
如果***小于或等于***pivot，则指针继续向***右***移动;  
如果***大于***pivot，则***left***指针停止移动，然后让***left***和***right***所指向的元素交换  
最后当***left***和***right***重合时，就将指向元素和基准元素交换，结束。  

***单边循环法***  
选定基准元素pivot，设置一个mark指针指向数列起始位置，这个mark指针代表***小于基准元素的区域边界***  
从基准元素的下一个位置开始遍历  
如果遍历到的元素大于基准元素，往后遍历  
如果遍历到的元素小于基准元素，则需要做两件事  
第一，把mark指针右移1位，因为代表这小于基准元素的区域变大了  
第二，让最新遍历到的元素和mark指针所在位置的元素交换位置，因为这个新元素就是属于小于基准元素的区域  
最后把基准元素交换到mark指针所在位置， 结束，此时基准元素两边就是一小一大的区域。

# 堆排序
### 步骤
1. 把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆;需要从大到小排序，则构建成最小堆  
2. 循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶

### 时空复杂度
- 空间复杂度：没有开辟额外的集合空间，所以为***O(1)***
- 时间复杂度：先把无序数组构建成二叉堆，这一步为***O(n)***，然后需要进行n-1次循环，每次循环调用一次downAdjust方法，所以计算规模是
(n-1)xlogn，所以为***O(nlogn)***

## 堆排序和快速排序比较  
1. 相同点
    - 平均时间复杂度都是***O(nlogn)***  
    - 都是***不稳定排序***
2. 不同点
    - 快排的最坏时间复杂度是***O(n²)***
    - 堆排序的最坏时间复杂度是***O(nlogn)***

此外，快速排序递归和非递归方法的平均**空间复杂度**都是***O(nlogn)***  
而堆排序的空间复杂度是***O(1)***
