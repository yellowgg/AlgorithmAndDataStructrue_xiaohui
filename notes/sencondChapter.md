# 单链表
#### 时间复杂度
- 查找：链表中的数据只能按顺序进行访问，最坏的时间复杂度为O(n)  
- 插入和删除：如果不考虑插入、删除操作之前查找元素的过程，只考虑纯粹的插入和操作，时间复杂度都是O(1)  
#### 对比：数组和链表相关操作的性能
|     | 查找 | 更新  |  插入 | 删除  |
| ----| --- | ---- | -----|  ---  |
| 数组 | O(1)| O(1) | O(n) |  O(n) |
| 链表 | O(n)| O(1) | O(1) |  O(1) |  
从表格可以看出，数组的优势在于能够快速定位元素，对于读多写少的场景来说，用数组更适合  
相反，链表的优势在于能够灵活地进行插入和删除操作，在尾部频繁插入、删除元素，用链表。
# 栈
先入后出，(First In Last Out) FILO
#### 时间复杂度
入栈和出栈只会影响到最后一个元素，不涉及其它元素的整体移动，  
所以无论是以数组还是链表实现，  
- 入栈出栈：都是O(1)
#### 应用
- 递归，回溯方法的调用链
- 面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面。 
# 队列
先入先出，(First In First Out) FIFO
#### 时间复杂度
- 循环队列的入队出队时间复杂度都是O(1)
#### 应用
- 多线程，争夺公平锁的等待队列
- 爬虫，网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照队列的顺序来依次抓取和解析的
#### 另
循环队列：（队尾下标+1）%数组长度=队头下标  
双端队列：综合了栈和队列的优点，对双端队列来说，从队头端可以入队或出队，从队尾端也可以入队或出队  
优先队列：优先级高就先出队，基于二叉堆实现
# 散列表（哈希表）
#### 哈希函数
通俗来说，比如访问数组，直接访问a[1]就可以获得元素，因为有了下标  
散列表本质上也是一个数组，也相当访问它的下标就可以获得元素  
一般而言获取散列表的值是输入一个Key，就获得一个Value，也需要下标  
*哈希函数*的作用就是将Key转换成下标
- index = HashCode(Key)%Array.length
#### 哈希冲突
由于数组的长度有限，当插入的Entry(键值对)越来越多，不同的Key通过哈希函数获得的下标有可能是相同的  
这种下标的冲突就是*哈希冲突*,解决方法有两个
- 开放寻址法
- 链表法
***
*开放寻址法*的思路就是这个下标不行就换下一个下标，总之就是换，随便用什么方法。  
*链表法*的思路是散列表的数组的每一个元素不仅仅是一个Entry对象，它还是一个链表的头节点，当冲突时就往所对应的链表中添加即可  
总的来说，如果把散列表数组当成一个横向的数组，那么*开放寻址法*就是横向解决哈希冲突，*链表法*就是纵向解决哈希冲突  
#### 扩容
散列表需要扩展长度，对于JDK中的散列表实现类HashMap来说，影响其扩容的因素有两个。  
-  **Capacity**,即HashMap的当前长度
-  **LoadFactor**,即HashMap的负载因子，默认值为0.75f 
 
衡量HashMap需要进行扩容的条件如下  
- **HashMap.Size >= Capacity X LoadFactor**  
#### 扩容方法
1. **扩容**,创建一个新的Entry空数组，长度是原数组的2倍
2. **重新Hash**,遍历原Entry数组，把所有的Entry重新Hash到新数组中，重新Hash的原因是长度扩大后，Hash的规则也随之而变  







# 本章小结
- 什么是数组

数组是由有限个相同类型的变量所组成的有序集合  
物理存储方式是顺序存储  
访问方式是随机访问  
利用下标查找数组元素的时间复杂度是O(1)  
中间插入、删除数组元素的时间复杂度是O(n)
- 什么是链表

链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针  
物理存储方式是随机存储
访问方式是顺序访问  
查找链表节点的时间复杂度是O(n)
中间插入、删除节点的时间复杂度是O(1)
- 什么是栈

栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现  
栈包括入栈和出栈操作，遵循*先入后出*的原则(FILO)
- 什么是队列

队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现  
队列包括入队和出队操作，遵循*先入后出*的原则(FIFO)
- 什么是散列表

散列表也叫哈希表，是存储Key-Value映射的集合  
对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作  
散列表通过*哈希函数*实现Key和数组下标的转换  
通过*开放寻址法*和*链表法*解决*哈希冲突*
